# -*- coding: utf-8 -*-
"""A1_Thomas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hh9uCgU7JGfrf_QIP3ImRjBlNkvbp0Kd
"""

import os
import random
from PIL import Image
import requests
from io import BytesIO

import numpy as np
import matplotlib.pyplot as plt

def true_ribbon_shuffle(deck, split=20):
    '''
    deck shuffle
    TODO: this doc string
    '''
    assert len(deck) > split, 'Split is too big for deck'
    assert split > 0, 'Split must be positive integer'
    assert isinstance(split, int) , 'Split must be positive integer'
    
    # Check if first or second split is smallest
    if split < len(deck) - split:
        split_1 = deck[:split]
        split_2 = deck[split:]
        num_its = split
        step_size = (len(deck) - split)//split
    else:
        split_1 = deck[split:]
        split_2 = deck[:split]
        num_its = len(deck) - split
        step_size= split//(len(deck) - split)
    
    output = []
    for n in range(num_its):
        output.append(split_1[n])
        output.extend(split_2[n*step_size:(n+1)*step_size])
        
    output.extend(split_2[num_its*step_size:])  # Add remainded of split_2 to output
    
    return output

deck_20 = [n for n in range(20)]

true_ribbon_shuffle(deck_20, 10)

def arnold_map_gen(matrix, p=1, q=1, r=1, s=2):
    '''
    bla bla
    .. math::
        x_{t+1} = px_{t} + qy_{t}
        y_{t+1} = rx_{t} + sy_{t}
    '''
    
    nx,ny = matrix.shape[0:2]
    assert (nx == ny & ny > 1)
    x, y = np.arange(nx), np.arange(ny)
    xx, yy = np.meshgrid(x, y, sparse=False, indexing='ij')
    
    return matrix[(p*xx + q*yy) % nx, (r*xx + s*yy) % ny]

def arnold_gen_cycle(matrix, p=1, q=1, r=1, s=2, maxit=360, ret_mat=False):
    '''
    TODO
    ''' 
    
    matrix_shuffle = matrix.copy()
    
    for n in range(maxit):
        matrix_shuffle = arnold_map_gen(matrix_shuffle, p, q, r, s)
        if np.all(matrix_shuffle == matrix):
            if not ret_mat:  
                return n   
            else:    
                return matrix_shuffle

#n = 16
#testmatrix = np.arange(n*n).reshape(n, n)
#print(testmatrix)

#n = 354
#testmatrix = np.arange(n*n).reshape(n, n)
#print(testmatrix)

def img_to_array(img_site):
    '''
    '''

    image_url = img_site
    response = requests.get(image_url)
    img = Image.open(BytesIO(response.content))
    testmatrix = np.array(img)
    
    return testmatrix

catmat = img_to_array('https://www.jasondavies.com/catmap/catmap.jpg')
restore = arnold_gen_cycle(catmat)
print ('Image restored after iteration', restore)

catmat_shuffle = arnold_gen_cycle(catmat, ret_mat=True)
print ('Image after', restore, 'iterations: \n')
plt.imshow(catmat_shuffle)
plt.show()

def combo_cycle(matrix, ret_mat=False):
    '''
    '''

    print ('For (p,q,r,s)=')
    for p in range(1,3):
        for q in range(1,3):
            for r in range(1,3):
                for s in range(1,3):
                    results = arnold_gen_cycle(matrix, p, q, r, s)
                    print (p,q,r,s, ': Cycle at iteration', results)

combo_cycle(catmat)

def arnold_matrix_cycle(N, p=1, q=1, r=1, s=2, maxit=350, 
                        exit_on_cycle=False):
    '''
    TODO
    '''
    
    # N may be given for the x and y axis separetly to account for non-square matrices
    assert(N.shape[0:2] == (2, 1)), 'N must be vertical array of length'
    
    matrix_init = np.matrix([[p, q], [r, s]])
    matrix = matrix_init.copy()
    identity_mat = np.matrix([[1, 0], [0, 1]])
    cycle_at = []

    for n in range(maxit):
        matrix = (matrix @ matrix_init) % N
        
        #if np.all(matrix == matrix_init):
        if np.all(matrix == identity_mat):
            #print('Identity at:', n)
            if exit_on_cycle:
                return n + 1
            else:
                cycle_at.append(n + 1)
    if not exit_on_cycle:
        return cycle_at

#arnold_matrix_cycle(np.array([4, 4]).reshape(2,1), maxit=16)
print ('Identity matrix produced using n=')
arnold_matrix_cycle(np.array([354, 354]).reshape(2,1), exit_on_cycle=True)

def combo_ident(N, max_it):
    '''
    '''

    print ('For (p,q,r,s)=')
    for p in range(1,3):
        for q in range(1,3):
            for r in range(1,3):
                for s in range(1,3):
                    result = arnold_matrix_cycle(N, p, q, r, s, exit_on_cycle=False, maxit=max_it)
                    print (p,q,r,s, ': Identity at n=', result)

combo_ident(np.array([354, 354]).reshape(2,1), 1100)

"""$\mathcal{O}(a) = 0\; \forall\,a\in\mathcal{N}$"""

def mod_exp_order(a, N, maxit=int(10e6), print_on=False):
    '''
    TODO
    '''
    
    b = a 
    seen_before = {b} # To check for cycles
    
    for n in range(maxit):
        # If b = a^r = 1 mod N
        if b == 1:
            if print_on:
                print('Order of %s is %s'%(a, n+1))
            return n+1
        
        b = (b * a) % N          # b = a^(r+1) mod N
        
        # Check for non-unitary cycles
        if b in seen_before:
            if print_on:
                print('Infinite Order')
            return np.inf
        
        # Add current a^r to items seen before 
        seen_before.add(b)

order = {}
for a in range(2,11):
    for N in range(1,1001):
        order['a:' + str(a) + ' N:' + str(N)] = mod_exp_order(a, N)
print (order)

mod_exp_order(3, 3, print_on=True) # 3 Mod 3 = 0

mod_exp_order(2, 5, print_on=True)

def gcd_1(a, b):
    '''
    TODO
    '''
    
    while b != 0:
        t = b
        b = a % b
        a = t
    return a

def gcd_2(a, b):
    '''
    TODO
    '''
    
    while a != b:
        if a > b:
            a = a - b
        else:
            b = b - a
    return a

a = np.random.randint(0, 100000)
b = np.random.randint(0, 100000)

timeit(gcd_1(a, b))

timeit(gcd_2(a, b))

def int_factor(N):
    '''
    TODO
    '''
    
    # Check if two is a factor
    if N % 2 == 0:
        return 2
    
    # Create possible search space
    pos_r = np.arange(2, N-2)
    np.random.shuffle(pos_r)
    
    # Calculate gcd
    
    # Find order of a, r
    
    # Calculate a^(r/2) mod N
    
    #



N = 100

pos_r = np.arange(2, N-2)
np.random.shuffle(pos_r)

print(pos_r)

truth_arr = np.zeros(N-4)
for n in range(2, N-2):
    truth_arr[n-2] = n in pos_r
np.all(truth_arr)





